/* autogenerated by Processing revision 1297 on 2025-06-10 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import netP5.*;
import oscP5.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class concertInteractif extends PApplet {

/* Program for an interactive percussion concert
    APO33
    Author: Snati1206
*/

// Importing the OSC libraries to communicate with the users android app


// Importing hashmap libraries to create a dictionary type of data structure
//import java.util.HashMap;
 
int backgroundColor = 255;

// Declaring the object that spawns the shapes
ShapeManager shapeManager;

// Declaring the object that spawns text
JSONObject instructionsList; 
Instructions instructions;

// Declaring the Timer that shows at the bottom
Timer timer;

// Declaring the number of musicians
PlayerManager playerManager;
boolean isInputIn = false;
String userInput = "";
int numPlay; // number of musicians

// Temp stuff
String[] playNames = {"Nat","Jules","Jen","Rom","Gab"};

// Declaring the object destruction max range in z
float MaxRange = -2000;

// Declaring the votingManager

LogicManager logicManager;

// Section for the OSC connections and sending of Data
OscP5 oscp5;
NetAddress remoteLocation;

public void setup()
{
  /* size commented out by preprocessor */;
  background(backgroundColor);
  
  // The shapes go here  
  shapeManager = new ShapeManager();
  
  // The text spawner goes here
  instructionsList = loadJSONObject("instructions.json");
  instructions = new Instructions(instructionsList, width/2, height/2, 0);
  
  // The timer goes here
  timer = new Timer(30);  
  
  // The playerManager goes here
  playerManager = new PlayerManager();
  
  // The Osc stuff goes here  
  oscp5 = new OscP5(this,8000);
  remoteLocation = new NetAddress("192.168.8.255", 7500);
  
  // The voting logic goes here
  logicManager = new LogicManager(timer);
  
}

public void draw()
{
  background(backgroundColor);
  
  //Display text
  fill(0);
  textSize(60);     
  textAlign(CENTER, BOTTOM);
  text("CHOIX POUR PERCUSSION",width/2,height -7*height/8 );
  
  //Ask for number of musicians
  playerManager.start();
  
  //Text related stuff
  instructions.display();
  
  //Draw Shapes
  shapeManager.displayShapes(); //need to change this to display only the one that matches the winning shape of each round
  
  //Draw Timer
  timer.update();
  timer.display(width/2,height-20);
  
  //Voting Logic calls spawnShape after each round spawning the winning shape and also the associated instructions from text
  logicManager.update();
  logicManager.sendTime(oscp5, remoteLocation);
}

public void keyPressed()
{
  if (key == 'b'){
    timer.restart = true;
  }
  if (key == 'c'){
    instructions.destroy();
    timer.restart = false;
  }
  if (key == 's'){
    if (playerManager.playerList.size() == playNames.length){
      for (int i = 0; i < playerManager.playerList.size(); i++){
        Player player = playerManager.playerList.get(i);
        player.namePlayer = playNames[i];
    }    
   }
     logicManager.sendTime(oscp5,remoteLocation);
  }
  
  // stores the number of musicians when the input is an int and then ENTER RETURN
  if (!isInputIn) {
    if (key == ENTER || key == RETURN) {
      // Process the input when Enter is pressed
      int n = PApplet.parseInt(userInput);
      isInputIn = true; // input marked as complete
      playerManager.spawnPlayers(n);
    } 
    else if (key != CODED) {
      // Append the typed character to the input
      userInput += key;
      playerManager.n = PApplet.parseInt(userInput);
    }    
  }
    
  if (key == 'p'){
    for (int i = 0; i < playerManager.playerList.size(); i++){
      Player player = playerManager.playerList.get(i); 
      println(player.name());
      println(player.isOn);
    }      
  }
  
  if (key == 'i'){
    println("number of IP's = " + logicManager.publicCounter);
  }
}


public void oscEvent(OscMessage msg) {
  println("Received OSC message: " + msg.addrPattern()); 
  // Forward the message to LogicManager
  logicManager.voteCounting(msg);
  logicManager.playerActivate(msg);
  logicManager.androidStart(msg);
}

public void exit(){
  oscp5.stop(); // Stop the OSC server
  super.exit(); // Call the default exit behavior
}

  

// Storing all the instructions into a list and ready to display them

class Instructions{
  
 JSONObject instructions; //json that contains the instructions divided by category
 JSONArray currentList; //empty jsonArray that takes the form of one categorie acording to user input
 PFont apoFont;
 float x,y,z; //text position
 int index = -1; //starting is -1 to avoid printing anything
 float textSize = 50;
 boolean isVisible = false;
 float movSpeed = 0.2f;
 float zPos;
 float alpha = 255;
 
 // Arrays for each category
 JSONArray _textural;
 JSONArray _rhythmic;
 JSONArray _abstract;
 JSONArray _silence;
 JSONArray _noise;
 
 Instructions(JSONObject list, float x, float y, float z){    
   this.instructions = list;  
   this.x = x;
   this.y = y;
   this.z = z;
   zPos = z;
   
   // Defining the font
   apoFont = createFont("Arial", 40, true);
   
   // Storing all the categories of the Instructions.json in an individual array
   _textural = instructions.getJSONArray("Textural"); //spawns in Bezier Shape
   _rhythmic = instructions.getJSONArray("Rhythmic"); //spawns in Points Shape
   _abstract = instructions.getJSONArray("Abstract"); //spawns in Traces type of Shape
   _silence = instructions.getJSONArray("Silence"); //spawns in Silence, no shape for it
   _noise = instructions.getJSONArray("Noise"); //spawns in Noise Shape
 }
 
 //Assigning each instruction category by using a string in the spawn method
 public void spawn(String category){
   if (!isVisible && instructions != null){
     
      switch (category) {
        case "Textural":
          currentList = _textural;
          break;
        case "Rhythmic":
          currentList = _rhythmic;
          break;
        case "Abstract":
          currentList = _abstract;
          break;
        case "Silence":
          currentList = _silence;
          break;
        case "Noise":
          currentList = _noise;
          break;
        default:
          println("Invalid category: " + category);
          return;
      }
     index = PApplet.parseInt(random(currentList.size()));
     isVisible = true;
   }

 }
 
 public void display(){
   if (isVisible && index >= 0){
     alpha -= movSpeed;
     if (alpha<0){
     alpha = 0;
   }
     fill(0,0,0,alpha);
     textSize(textSize);     
     textAlign(CENTER, BOTTOM);
     pushMatrix();
     translate(0,0,zPos);
     text(currentList.getString(index),x,y);
     popMatrix();
     
     //z axis move speed
     zPos -= movSpeed;
   }
 }
 
 public void destroy(){
   isVisible = false;
   zPos = z;
   alpha = 255;
   }
}

// Logic to manage the interaction

class LogicManager {
  
  int bez = 0, nois = 0, points = 0, txt = 0, trace = 0, nothing = 1;
  int play1 = 0, play2 = 0, play3 = 0, play4 = 0, play5 = 0, play6 = 0; //count of players 
  Timer timer;
  StringList IPStorage; //Dynamic array that stores different Ip's from incoming messages.
  int publicCounter = 0;
  
  
  LogicManager(Timer timer){
    this.timer = timer;
    this.IPStorage = new StringList();
  }
  
  //Method that listens for the /start message to send back the number of musicians to the audience apps
  public void androidStart (OscMessage msg){  
    if (msg.checkAddrPattern("/start")){
    //Send OSC message to all android apps
      OscMessage nPlayers = new OscMessage("/nplayers");
      nPlayers.add(playerManager.n); //send the number of players to the android apps.
      oscp5.send(nPlayers, remoteLocation);
    }  
  }
  
  //Method that sends the current time to all other apps
  public void sendTime(OscP5 oscp5, NetAddress address){
    OscMessage msg = new OscMessage("/timer");
    msg.add(timer.timeLeft);
    oscp5.send(msg, address);
    //println("sent oscMessage " + msg.typetag() + msg.get(0).floatValue());
  }
  
  //Method that turns on/off the players/musiciens
  public void playerActivate (OscMessage msg){    
    if (msg.checkAddrPattern("/addIP")) {
      NetAddress sender = msg.netAddress(); // Get the sender's address
      String senderIP = sender.address(); // Extract the IP address
      if (!IPStorage.hasValue(senderIP)) { // Avoid duplicates
        IPStorage.append(senderIP); // Add the IP to the list
        println("Added Sender IP: " + senderIP);
      } else {
        println("IP already exists: " + senderIP);
      }
    }
  
    // Removes an IP from the Array
    if (msg.checkAddrPattern("/removeIP")) {
      NetAddress sender = msg.netAddress(); // Get the sender's address
      String senderIP = sender.address(); // Extract the IP address
      int index = IPStorage.index(senderIP); // Find the index of the IP
      if (index != -1) { // Check if the IP exists in the list
        IPStorage.remove(index); // Remove the IP using its index
        println("Removed Sender IP: " + senderIP);
      } else {
        println("IP not found: " + senderIP);
      }
    }
    
    // Counts votes for player activation and compares it to the total of IP's registered
    // After the concert it can be useful to spawn this based on the number of players of the concert    
    switch (msg.addrPattern()){
      case "/play1":
        int play1state = msg.get(0).intValue();
        play1 = play1 + play1state;
        println(play1);
        if (play1 <0){
          play1 = 0;
        }
  
        if (play1 > publicCounter/2) {
          Player player = playerManager.playerList.get(0);
          player.isOn = true;
        } 
        else {
          Player player = playerManager.playerList.get(0);
          player.isOn = false;
        }
        break;
  
      case "/play2":
        int play2state = msg.get(0).intValue();
        play2 = play2 + play2state;
        if (play2 <0){
          play2 = 0;
        }
        println(play2);
  
        if (play2 > publicCounter/2) {
          Player player = playerManager.playerList.get(1);
          player.isOn = true;
        } 
        else {
          Player player = playerManager.playerList.get(1);
          player.isOn = false;
        }
        break;
  
      case "/play3":
        int play3state = msg.get(0).intValue();
        play3 = play3 + play3state;
        println(play3);
        if (play3<0){
          play3 = 0;
        }  
        if (play3 > publicCounter/2) {
          Player player = playerManager.playerList.get(2);
          player.isOn = true;
        }
        else {
          Player player = playerManager.playerList.get(2);
          player.isOn = false;
        }
        break;
  
      case "/play4":
        int play4state = msg.get(0).intValue();
        play4 = play4 + play4state;
        println(play4);
        if(play4<0){
          play4=0;
        }
  
        if (play4 > publicCounter/2) {
          Player player = playerManager.playerList.get(3);
          player.isOn = true;
        } 
        else {
          Player player = playerManager.playerList.get(3);
          player.isOn = false;
        }
        break;
  
      case "/play5":
        int play5state = msg.get(0).intValue();
        play5 = play5 + play5state;
        println(play5);       
        if(play5<0){
          play5 = 0;
        }  
        if (play5 > publicCounter/2) {
          Player player = playerManager.playerList.get(4);
          player.isOn = true;
        } else {
          Player player = playerManager.playerList.get(4);
          player.isOn = false;
        }
        break;
  
      case "/play6":
        int play6state = msg.get(0).intValue();
        play6 = play6 + play6state;
        println(play6);
        if (play6<0){
          play6 = 0;
        }
        if (play6 > publicCounter/2) {
          Player player = playerManager.playerList.get(5);
          player.isOn = true;
        } 
        else {
          Player player = playerManager.playerList.get(5);
          player.isOn = false;
        }
        break;
        
      default :
        break;
    }
  }
  
  // OSC Method that listens to incoming messages
  public void voteCounting (OscMessage msg){
    switch (msg.addrPattern()) {
      case "/texture":
        bez++; // Increment the vote for "bez" 
        println("bez= " + bez);
        break;

      case "/noise":
        nois++; // Increment the vote for "nois"
        println("noise= " + nois);
        break;

      case "/rhythmic":
        points++; // Increment the vote for "points"
        println("points= " + points);
        break;

      case "/silence":
        txt++; // Increment the vote for "txt"
        println("text= " + txt);
        break;

      case "/abstract":
        trace++; // Increment the vote for "trace"
        println("trace= " + trace);
        break;
        
      case "/skip":
        nothing++; // Increment the vote for "Nothing"
        println("nothing= " + nothing);
        break;

      default :
        break;
    } 
  }
  
  // Method to reset the votes, it's called in the update method inside the same class
  public void resetVotes(){
    bez = 0;
    nois = 0;
    points = 0;
    txt = 0;
    trace = 0;
    nothing = 1;
  }
  
  // Method to find the winner from the voting window and return it as a String, it could return a Shape instead
  // It also spawns the winner of the round (Shape and Text)
  public String returnChoice(){
    
    int[] votes = {bez, nois, points, txt, trace, nothing};
    int maxVotes = max(votes); //pick the one with most votes
    // Choose the winner
    if (bez == maxVotes) return "Bezier"; //Spawns Bezier shape and Textural Text
    if (nois == maxVotes) return "Noise"; //Spawns Noise shape and Noise Text
    if (points == maxVotes) return "Points"; //spawns Points shape and Rhythmic text
    if (txt == maxVotes) return "Text"; //
    if (trace == maxVotes) return "Traces";
    if (nothing == maxVotes) return "Nothing";
    return null;
  }
  
  // Update Method, selects the winner at the start of a new round, and returns a string, with the name of the winner
  public void update(){
    if (timer.timeLeft == timer.timeWindow ){ 
      //println("round winner is " + returnChoice()); //test debug round winner
      returnChoice();
      shapeManager.spawnShape(returnChoice()); //Spawns the winning shape of each round
      resetVotes();       
    }
    publicCounter = IPStorage.size(); //Updates the number of voters by storing their IP's, when the Android app closes it sends removeIP osc message to remove it from the list
  }
}

//Player class, will store the name of players and their color when they have to play

class Player{
  
  int n; //player number
  String namePlayer;
  int active; //player counter
  float x, y; //position of the player
  float w, h; //weidth and height of the player box
  int c; //color of the box
  boolean isOn = false; //boolean that will decide if the player has to play or not by applying color to it's box in the screen
    
  // Constructor  
  Player(int n, float x, float y, float w, float h){
    this.n = n; 
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.c = color(139,236,118);
  }
  
  public String name(){
    String name = ("musicien_" + "_" + this.n);
    namePlayer = name;
    return name;
  }
    
  public void display(){ 
    
    if (isOn){
      fill(c);
    }
    else {
      noFill();
    }
    stroke(0);
    rectMode(CORNER);
    rect(x,y,w,h); //Creating rectangle for the musician
    
    float fitText = min(w,h)/3;
    textSize(fitText);
    
    fill(0);
    textAlign(CENTER,CENTER); //showing player name at the center of the rectangle
    text(namePlayer + n,(x+w/2),(y+h/2)); //text should appear at the center of the box    
  }
}

class PlayerManager{
  
  ArrayList<Player> playerList; // list of players
  int n; // number of players from input
  boolean isInput = false; // boolean to turn to true once we have entered the number of musicians
  
  PlayerManager(){
    playerList = new ArrayList<Player>();
  }
  
  //
  public void display() {
    if (isInput) {
      for (Player player : playerList) {
        player.display(); // Display each player
      }
    }
  }
  
  public void addPlayer(Player player){
    playerList.add(player);
  }
  
  // Method that adds all players to the playertype Array
  public void spawnPlayers(int n){
    
    float boxWidth = width/n;
    float boxHeight = 70;
    
    for (int i = 0; i<n ; i++){
      Player player = new Player(i+1, i* boxWidth, height-110, boxWidth, boxHeight);
      addPlayer(player);      
    }   
    isInput = true;
  }
 
  //Method to ask for number of players and then display them into the screen
  public void start(){
    if (!isInput) {
    // Ask for the number of players
      fill(0);
      textAlign(CENTER,CENTER);
      text("Enter the number of musicians: " + n, width/2, height/2);
    } else {
    // Display the players
      this.display();
    }
  }
   
}


//Basic Shape class that contains the basic parameters needed for this shapes,
//like 3D position, movement, colors, and creation and destruction
class ShapeGen {
  
  float x,y,z;
  boolean isVisible = false;
  float movSpeed = 1.2f; // for transposing the images
  float zPos; //variables to destroy automatically the shapes

  
  ShapeGen(float x, float y, float z){
    
    this.x = x;
    this.y = y;  
    this.z = z;
    this.zPos = z;
  }

  public void display() {
    
    if (isVisible){
      
      fill(0);
      pushMatrix();
      translate(0, 0, zPos);
      rect(x,y,50,50);  
      popMatrix();
      zPos -= movSpeed;
    }      
  }
  
  public void spawn(){
    
    if (!isVisible){
      isVisible = true;
    }  
  }
  
  public void destroy(){
    isVisible = false;
    zPos = z;   
  }
}

//This inherited classes will create the types of shapes, I used inheritance because
//it can help future coders to optimize code

// This shape produces a pointillism figure

class ShapePoints extends ShapeGen {
  ArrayList<Point> points; // List to store points
  float lastSpawnTime; // Time of the last point spawn

  ShapePoints(float x, float y, float z) {
    super(x, y, z);
    points = new ArrayList<Point>();
    lastSpawnTime = millis(); // Initialize the last spawn time
  }

  public void display() {
    if (isVisible) {
      // Move the shape along the z-axis
      zPos -= movSpeed;

      // Push the matrix for z-axis translation
      pushMatrix();
      translate(0, 0, zPos); // Apply z-axis movement

      // Spawn points randomly within a delay of 0.2 to 2 seconds
      if (millis() - lastSpawnTime > random(600, 2500)) {
        spawnRandomPoint();
        lastSpawnTime = millis(); // Reset the spawn timer
      }

      // Display and update points
      for (int i = points.size() - 1; i >= 0; i--) {
        Point p = points.get(i);
        p.display();
        p.update();

        // Remove the point if it has faded away
        if (p.alpha <= 0) {
          points.remove(i);
        }
      }

      // Pop the matrix after translation
      popMatrix();
    }
  }

  // Spawn a random point
  public void spawnRandomPoint() {
    float randomX = random(width / 8, width - width / 8); // Random x position across the screen
    float randomY = random(height / 7, height - height / 7); // Random y position across the screen
    float randomSize = random(10, 50); // Random size for the ellipse
    int randomColor = color(random(0, 255), random(0, 50), random(0, 50)); // Random dark color
    points.add(new Point(randomX, randomY, randomSize, randomColor));
  }

  // Inner class to represent a point
  class Point {
    float px, py, size; // Position and size of the point
    int col; // Color of the point
    float alpha; // Transparency of the point

    Point(float px, float py, float size, int col) {
      this.px = px;
      this.py = py;
      this.size = size;
      this.col = col;
      this.alpha = 255; // Start fully opaque
    }

    public void display() {
      fill(col, alpha); // Apply transparency
      noStroke();
      ellipse(px, py, size, size); // Draw the point
    }

    public void update() {
      alpha -= 2; // Gradually fade out
    }
  }
}

// This produces some kind of Picasso shapes or animated lines
//class ShapeBezier extends ShapeGen {

class ShapeBezier extends ShapeGen {
  ArrayList<BezierFigure> bezierFigures; // List to store Bezier figures
  int numFigures = 15; // Number of Bezier figures
  int currentFigureIndex = 0; // Index of the figure currently being drawn

  ShapeBezier(float x, float y, float z) {
    super(x, y, z);
    bezierFigures = new ArrayList<BezierFigure>();

    // Create Bezier figures
    for (int i = 0; i < numFigures; i++) {
      bezierFigures.add(new BezierFigure());
    }
  }
  
  @Override public 
  void spawn(){
    
    isVisible = true;
    bezierFigures.clear();
    for(int i = 0; i < numFigures; i++){
      bezierFigures.add(new BezierFigure());
    }
    currentFigureIndex = 0;
    zPos = z;
  }
  
  @Override public 
  void destroy(){
    isVisible = false;
    bezierFigures.clear();
    currentFigureIndex = 0;
    zPos = z;
  }
  
  public void display() {
    if (isVisible) {
      // Move the shape along the z-axis
      zPos -= movSpeed;
      pushMatrix();
      translate(0, 0, zPos); // Apply z-axis movement

      // Draw all completed figures
      for (int i = 0; i < currentFigureIndex; i++) {
        bezierFigures.get(i).displayFull();
      }

      // Draw the current figure incrementally
      if (currentFigureIndex < bezierFigures.size()) {
        BezierFigure currentFigure = bezierFigures.get(currentFigureIndex);
        currentFigure.update();
        currentFigure.display();

        // If the current figure is fully drawn, move to the next one
        if (currentFigure.isComplete()) {
          currentFigureIndex++;
        }
      }
      popMatrix();
    }
    else{
      destroy();     
    }
  }

  // Inner class to represent a Bezier figure
  class BezierFigure {
    float x, y;
    float x1, y1, x2, y2; // Start and end points
    float cx1, cy1, cx2, cy2; // Control points
    float r, g, b; // Color
    float t; // Parameter for drawing the curve incrementally

    BezierFigure() {
      // Initialize random positions for the points
      x = random(width);
      y = random(height);
      x1 = x + 40;
      y1 = y + 40;
      x2 = x1 + width/2;
      y2 = y1 + height/2 + 100;
      cx1 = random(width);
      cy1 = random(height);
      cx2 = random(width);
      cy2 = random(height);

      // Initialize random colors
      r = random(50, 255);
      g = random(50, 255);
      b = random(50, 255);

      // Initialize t
      t = 0; // Start drawing the curve from the beginning
    }

    public void update() {
      // Increment t to draw more of the curve
      t += 0.005f; // Adjust this value to control the drawing speed
      if (t > 1) {
        t = 1; // Stop drawing once the curve is fully drawn
      }
    }

    public void display() {
      // Draw the curve incrementally
      if (isVisible){
        stroke(r, g, b, 120); // Semi-transparent stroke
        strokeWeight(1);
        fill(r, g, b, 70);
      }
      else{
        noStroke();
        noFill();
      }
      beginShape();
      for (float i = 0; i < t; i += 0.005f) {
        float px = bezierPoint(x1, cx1, cx2, x2, i);
        float py = bezierPoint(y1, cy1, cy2, y2, i);
        vertex(px, py);
      }
      endShape();
    }

    public void displayFull() {
      // Draw the full curve
      stroke(r, g, b, 60); // Semi-transparent stroke
      strokeWeight(1);
      fill(r, g, b, 100);
      bezier(x1, y1, cx1, cy1, cx2, cy2, x2, y2);
    }

    public boolean isComplete() {
      // Check if the curve is fully drawn
      return t >= 1;
    }
  }
}

// This produces some kind of traces like from a brush in painting
//class ShapeTraces extends ShapeGen {

class ShapeTraces extends ShapeGen {
  int num = 40; // Number of points in the trace
  float[] mx = new float[num]; // Array to store x-coordinates
  float[] my = new float[num]; // Array to store y-coordinates
  float noiseOffsetX = random(3000); // Noise offset for x
  float noiseOffsetY = random(2000); // Noise offset for y

  ShapeTraces(float x, float y, float z) {
    super(x, y, z);
  }

  public void display() {
    if (isVisible) {
      // Move the shape along the z-axis
      zPos -= movSpeed;

      // Update the noise-based trajectory
      int which = frameCount % num;
      mx[which] = width / 2 + sin(noise(noiseOffsetX) * TWO_PI) * width / 4; // Noise-based x-coordinate
      my[which] = height / 2 + cos(noise(noiseOffsetY) * TWO_PI) * height / 4; // Noise-based y-coordinate
      noiseOffsetX += random(0.001f,0.01f); // Increment noise offset for x
      noiseOffsetY += random(0.001f,0.01f); // Increment noise offset for y

      // Draw the trace
      pushMatrix();
      translate(0, 0, zPos); // Apply z-axis movement
      noStroke();
      fill(255, 0, 102, 153); // Semi-transparent red
      for (int i = 0; i < num; i++) {
        int index = (which + 1 + i) % num; // Get the correct index in the circular buffer
        ellipse(mx[index], my[index], i, i); // Draw the ellipse with increasing size
      }
      popMatrix();
    }
    else {
      destroy();
    }
  }
}

// This produces the a 2D visualisation of a noise waveform
class ShapeNoise extends ShapeGen {
  
  ShapeNoise(float x, float y, float z){
    super(x,y,z);
  }
  public void display() {
    if (isVisible){
      
      fill(0, 169, 20);
      pushMatrix();
      translate(0, 0, zPos);
      rect(x,y,50,50);  
      popMatrix();    
      zPos -= movSpeed;
    }    
  }
}

//This will manage the creation and destruction of shapes
class ShapeManager{
  
  ArrayList<ShapeGen> shapes;
  String voteResult;
  ShapePoints figPoints;
  ShapeBezier figBez;
  ShapeNoise figNoise;
  ShapeTraces figTrace;

  ShapeManager(){
    shapes = new ArrayList<ShapeGen>();
    figPoints = new ShapePoints(width/2,50+height/2,100);
    shapes.add(figPoints);
    figBez = new ShapeBezier(width/2,50+height/2,100);
    shapes.add(figBez);
    figNoise = new ShapeNoise(width/2,50+height/2,100);
    shapes.add(figNoise);
    figTrace = new ShapeTraces(width/2,50+height/2,100);
    shapes.add(figTrace); 
  }
    
  public void loadShapes(ShapeGen shape){
    shapes.add(shape);
  }

  // Method to display all shapes
  public void displayShapes() {
    for (ShapeGen shape : shapes) {
      shape.display(); // Continuously
    }
  }
    
  public void destroyShape(ShapeGen shape){
    shape.destroy();
    }

  public void spawnShape(String voteResult){
    clearAllShapes();
    instructions.destroy();
    
    switch (voteResult) {
      case "Points":
        figPoints.spawn();
        instructions.spawn("Rhythmic");
        println("Spawning Points shape");
        break;

      case "Bezier":
        figBez.spawn();
        instructions.spawn("Textural");
        println("Spawning Bezier shape");
        break;

      case "Noise":
        figNoise.spawn();
        instructions.spawn("Noise");
        println("Spawning Noise shape");
        break;

      case "Traces":
        figTrace.spawn();
        instructions.spawn("Abstract");
        println("Spawning Traces shape");
        break;
      
      case "Text":
        instructions.spawn("Silence");
        println("Spawning Silence only");
        break;
        
      case "Nothing":
   //     println("Nothing happens");
        break;

      default:
        println("Unknown vote result: " + voteResult);
        break;
    }  
  }

  public void clearAllShapes() {
    for ( ShapeGen shape : shapes){
      shape.destroy();
    }
  }
}

//Timer that opens a window for the public to choose the next musical actions

class Timer{
  
  float timeLeft;
  float timeWindow;
  boolean restart = false; //bool to trigger a changement of scene by the public  
  //positioning  
  float x, y;
  
  Timer(float timeIn){
    this.timeWindow = timeIn; 
    this.timeLeft = timeIn; // it starts the same as the time window then it decreases
  }
  
  //Update timer by seconds
  public void update(){
    
    if (restart != false){
      if (timeLeft > 0){
      timeLeft -= 1.0f/frameRate; //reduce time that's left in seconds and limit it at 0
      } 
      else {
        timeLeft = 0;
        restart = false;
      }    
    }    
    else {
      timeLeft = random(20,timeWindow);
      timeWindow = timeLeft;
      restart = true;
    }    
   }

  //asigns a position to the timer bar
  public void display(float x, float y){
    
    this.x = x;
    this.y = y;
    fill(0,0,0);
    float rectWidth = map(timeLeft, 0, timeWindow, 0, width-100); // Map timeLeft to rectangle width
    rectMode(CENTER);
    rect(x, y, rectWidth, 20, 5); // Draw the rectangle    
  }  
}


  public void settings() { fullScreen(P3D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "concertInteractif" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
